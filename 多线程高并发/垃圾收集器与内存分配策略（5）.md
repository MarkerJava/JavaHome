*首先想想那些内存需要回收？什么时候回收？如何回收？*

### 1、为如何了解GC

虽然目前内存的动态分配与内存回收技术已经很成熟了，看起来基本进入“自动化”时代，为何还要了解GC，因为当需要排查各种内存溢出、内存泄漏 问题时候，我们需要对“自动化”的技术实施必要的监控和调节。

### 2、判断垃圾存在的两个方法

进行垃圾回收时，在堆里存放着几乎所有对象实例，垃圾收集器对堆进行回收前，首先要判断哪些“存活”、那些已经“死去”，常用算法如下。

**引用计数算法**

**思路**：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；**任何时刻计数器为0的对象就是不可能再被使用的。**

> 注：但是主流Java虚拟机里没有选用引用计数算法来管理内存，其中主要就是它很难解决对象之间相互循环引用问题。

**可达性分析算法（重点）**

在主流商用程序语言的主流实现中，都是通过可达性分析 来判定对象是否存活的。

**思路**：通过一系列的称为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索所*走过的路径称为引用链*，当一个对象到GC Roots没有任何引用链相连时，则证明对象是不可用的。

![image-20200507173911425](/Users/dimitri/Library/Application Support/typora-user-images/image-20200507173911425.png)

Java语言中，可作为GC Roots对象包括几种：

* 虚拟机栈中引用的对象
* 方法区中类静态属性引用的对象
* 方法区常量引用的对象
* 本地方法栈中JNI（一般说Native方法）引用对象

### 3、GC回收算法

标记-清除(Mark-Sweep)

标记-清除算法采用从根集合（GC Roots）进行扫描，对存活的对象进行标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，此算法一般没有虚拟机采用。

**优点**：解决了循环引用的问题、和复制算法相比，不需要对象移动，效率较高，而且还不需要额外的空间。

**缺点**：每个活跃的对象都要进行扫描、且要扫描两次，效率较低，收集暂停的时间比较长；内存碎片多

![image-20200507171720767](/Users/dimitri/Library/Application Support/typora-user-images/image-20200507171720767.png)

复制（Coping）

将内存分成两块容量大小相等的区域，每次只使用其中一块，当这一块内存用完了，就将所有存活对象复制到另一块内存空间，然后清除前一块内存空间。这样一来就不容易出现内存碎片的问题。

复制的代价较高，所以适合新生代，因为新生代的对象存活率较低，需要复制的对象较少；
需要双倍的内存空间，而且总是有一块内存空闲，浪费空间

![image-20200507171940128](/Users/dimitri/Library/Application Support/typora-user-images/image-20200507171940128.png)

标记-整理算法（Mark-Compact）

在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。
不会产生内存碎片，但是依旧移动对象的成本。

![image-20200507172157034](/Users/dimitri/Library/Application Support/typora-user-images/image-20200507172157034.png)

分代收集(Generationl Collection)

核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation）,在堆区之外还有一个代就是永久代（Permanet Generation）

![image-20200507172424632](/Users/dimitri/Library/Application Support/typora-user-images/image-20200507172424632.png)

### 4、垃圾收集器

### 5、内存分配与回收策略

### 6、对象优先在Eden分配