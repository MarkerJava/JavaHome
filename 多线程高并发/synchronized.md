### synchronized

### 1、面试被问synchronized，你真的回答对了吗

首先认识synchronized是什么，为什么要用它，它能给我们带来什么好处？

synchronized关键字是用来解决在多线程之间访问资源的同步性，就是当被synchronized修饰的方法或者代码块时，它会保证任意时刻只能有一个线程执行。

> 这样就确保线程互斥的访问同步代码、保证共享变量的修改能够及时可见、有效解决重排序问题。

### 2、你是如何使用synchronized关键字的

* 修饰实例方法：作用于当前对象实例加锁，进入同步代码前获得当前对象实例的锁。（弊端：比如A调用同步方法执行一个很长时间的任务，这时B就必须等待，有时候这种长时间等待是低效率且没有必要的）
* 修饰静态方法：作用范围是整个静态方法，作用的对象是这个类的所有对象（也就是整个类就一个锁）。
* 修饰代码块：被修饰的代码块称之为同步语句块，作用范围是大{}括起来的代码，作用对象就是调用这个代码块的对象。（格式：synchronized(类名){......}）

**synchronized方法是对当前对象加锁，synchronized代码块是对某个对象加锁**

但是在使用的时候要注意一点，就是尽量不要使用synchronized(String s)，因为JVM中字符串常量池具有缓存功能。

### 3、那你和我聊聊synchronized底层原理

* 同步方法块是通过 monitorenter 和 monitorexit 指令获取线程的执行权，
  * 注：当执行monitorenter指令时，线程就会获取monitor的持有权。当monitor为0时则成功获取 ，获取后就将锁计数为1，相当加1嘛。然后执行相应的monitorenter指令后，将锁计数器设为0，就表明锁被释放，如果获取锁失败那当前线程就会进入阻塞状态，等到锁被另一个线程释放为止。
* 同步方法通过加 ACC_SYNCHRONIZED 标识实现线程的执行权的控制，也就是JVM通过ACC_SYNCHRONIZED来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。

### 4、JDK 1.6之后，synchronized底层做了那些优化

JDK1.6中对锁的实现引入了大量的优化，比如偏向锁、轻量级锁、自旋锁、锁消除等技术减少锁操作的开箱的。其实锁主要存在四种状态依次是无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。它们之间通过竞争的激烈而逐渐升级，锁可以升级不可降级，目的就是为了提高获得锁和释放锁的效率。

### 线程池好处？

* 降低资源消耗
* 提高响应速度
* 提高线程的可管理性

