> 1、聊一聊ArrayList扩容机制？或者Arraylist是什么扩容的？

```reStructuredText
1、添加元素时，首先进行判断是否大于默认容量10
2、如果，小于默认容量，直接在原来基础上+1，元素添加完毕
3、如果，大于默认容量，则需要进行扩容，扩容核心是grow()方法
   3.1 扩容之前，首先创建一个新的数组，旧数组被复制到新的数组中
       这样就得到了一个全新的副本，我们在操作时就不会影响原来数组了
   3.2 然后通过位运算符将新的容量更新为旧容量的1.5陪（原来长度的一半再加上原长度也就是每次扩容是原来的1.5倍）
   3.3 如果新的容量-旧的容量<=0，就拿新的容量-最大容量长度如果<=0的，那么最终容量就是扩容后的容量
```

> 2、为什么ArrayList每次扩容是1.5陪，而不是2陪3陪呢？

因为，ArrayList的默认容量是10的，如果我们设置容量过大的话，会浪费空间。如果扩容小于1.5陪的话，有可能每次存进来的元素，都需进行扩容，这是很耗尽资源性能也会受到系影响。

> 3、ArrayList 与 LinkedList 区别?

*  `Arraylist` 底层使用的是 **`Object` 数组**；`LinkedList` 底层使用的是 **双向链表** 数据结构。
* `ArrayList`是支持高效的随机元素访问，同时也是它最擅长随机元素访问的。而`LinkedList` 不支持高效的随机元素访问。（快速随机访问就是通过元素的序号快速获取元素对象对应于`get(int index) `方法)。
* ArrayList的空间有点浪费，主要体现在list列表的结尾会预留一定的容量空间（也就是扩容为1.5陪，后面的0.5陪有点浪费，但是有一定的好处），而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间
* `ArrayList` 采用数组存储，插入和删除元素的时间复杂度受元素位置的影响，比如add`ArrayList` 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)，如果指定位置 i 插入和删除元素的话时间复杂度就为 O(n-i)，因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。
* `LinkedList` 采用链表存储，所以对于`add(E e)`方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)。果是要在指定位置`i`插入和删除元素的话，时间复杂度近似为`o(n))`因为需要先移动到指定位置再插入。

> 4、Arraylist 与 vector 区别?

最大区别是：Vector是线程安全的，它里面的方法都是直接或者间接的同步（synchronizetion）。而ArrayList没有一个方法是同步的。如果不需要保证线程安全的情况下建议使用Arraylist。

kCountlyStoredDeviceIDKey