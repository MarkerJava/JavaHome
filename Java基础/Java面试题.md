# 前言

# 第一部分	Java基础

## 一	Java基础

### 1.	JVM是什么

Java虚拟机（JVM）是运行Java字节码的虚拟机。JVM有针对不同系统的特定实现，主要是使用相同的字节码。

### 2.	JDK、JRE区别

JDK（Java development Kit）是Java的一个开发工具包，拥有了JRE所拥有的一切，它是能创建和编译程序的。

JRE是Java运行时环境，是运行已经编译Java程序所需的所有内容的集合，包括JVM、Java类库、Java命令和其他的一些基础构建。

### 3.	Java与C++的区别

Java的类是单继承（但是Java可以实现多个接口），而C++支持多继承。

Java有自动的内存管理机制，程序员不需要手动释放无用内存。

### 4.	Java有哪几种数据类型

| 基本类型 | 大小（占用位数） |  最小值   |     最大值     | 包装类型  | 占用字节 |
| :------: | :--------------: | :-------: | :------------: | :-------: | :------: |
| boolean  |        —         |     —     |       —        |  Boolean  |    1     |
|   char   |     16 bits      | Unicode 0 | Unicode 216 -1 | Character |    2     |
|   byte   |      8 bits      |   -128    |      +127      |   Byte    |    1     |
|  short   |     16 bits      |   - 215   |    + 215 -1    |   Short   |    2     |
|   int    |     32 bits      |   - 231   |    + 231 -1    |  Integer  |    4     |
|   long   |     64 bits      |   - 263   |    + 263 -1    |   Long    |    8     |
|  float   |     32 bits      |  IEEE754  |    IEEE754     |   Float   |    4     |
|  double  |     64 bits      |  IEEE754  |    IEEE754     |  Double   |    8     |

>整数形：`byte、int、long、short`
>
>浮点型：`float，double（3.14F位浮点型，没有F默认为double）`
>
>字符型：`char (文本型，Unicode编码的字符单元的字符型)`
>
>布尔型：`boolean`

### 5.	构造器可以被重写吗

构造器是不能被重写的，因为重写是子类方法重写父类的方法，而构造方法是的名称必须和类相同，这显然违背了重写构造方法的定义。**但是构造器可以被重载。**

### 6.	重写和重载有什么区别

**重载**：发生在同一个类中，方法名必须相同（参数类型、及个数、顺序不同）方法返回值和访问修饰可以不同。

**重写**：发生在子类，是指子类重写父类的方法名、参数列表必须相同，返回值范围小于或者等于父类。

### 7.	简单说Java程序初始化顺序

![736F11A0-A096-4E79-A36A-17C33AFE06E3](/Users/dimitri/Desktop/图片/736F11A0-A096-4E79-A36A-17C33AFE06E3.png)

Java程序初始化一般执行顺序为：1⃣️父类静态变量、2⃣️父类静态代码块、3⃣️子类静态变量、4⃣️子类静态代码块、5⃣️父类非静态变量、6⃣️父类非静态代码块、7⃣️父类构造函数、8⃣️子类非静态变量、9⃣️子类非静态代码块、🔟子类构造函数

### 8.	三大特性：封装 继承 多态

**封装**：封装是指把一个类对象私有化，隐藏实现通过将细节**私有化**把接口与实现分离，同时提供一些被外界访问的属性。好处：使得代码模块化，程序更加安全。

**继承**：继承是指使用已存在的类的定义作为基础建立新类的技术，新类的定义可以自己增加新的需求或更多功能，也可以用父类的功能，但是不能选择地继承父类。为什么要继承？实现代码重用。

**多态**：是父类型的引用指向子类型的对象，多态提供了另一个维度的接口与实现分离，以解耦做什么和怎么做，其实多态是消除类型之间的耦合的。好处：提高程序的可复用性和程序可扩展性及代码可维护性，所以不仅改善代码的组织，从而还提高代码的可读性。

### 9.	什么是方法返回值？

方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果，返回值就是用来接收该方法产生的结果。

例子：学校里的自动零售机，扔硬币，最后饮料出来

学校里的自动零售机就是—>【方法】，扔硬币就是—>【参数】，最后饮料出来就是—>【返回值】

### 10.	面向对象与面向过程

面向过程：强调解决问题时所有步骤，然后用函数(方法)把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。

面向对象：强调是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。面向对象强调的是对象。

例子：

面向过程：买菜-洗菜-做菜-装盘-吃-洗碗

面向对象：去饭店-吃

### 11.	String、StringBuffer 、StringBuilder 的区别

**String**：类中使用 final 关键字修饰字符数组来保存字符串，所以` String` 对象是不可变的。但是在 Java 9 之后，String 类的实现改用 byte 数组存储字符串 `private final byte[] value`;

**StringBuilder**：并没有对方法进行加同步锁，所以是非线程安全的。

**StringBuffer**：对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。

### 12.	成员变量和局部变量区别

1. 局部变量声明在方法、构造方法或者语句块中。局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁。但是，成员变量和局部变量都能被 final 所修饰。
2. 内存存储不同：如果成员变量是使用`static`修饰的，那么这个成员变量是属于类的，如果没有使用`static`修饰，这个成员变量是属于实例的。而对象存在于堆内存，`局部变量是在栈上分配的`。
3. 生存时间不同：成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。
4. 成员变量如果没有被赋初值：则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值，必须经过初始化，才可以使用。

### 13.	equals与==区别

equals（）：作用是判断两个对象是否相等，分为两种情况。第一：类没有覆盖equals方法，则通过equals比较该类的两个对象时，等价于==的。第二：类覆盖了，一般比较的是两个对象的内容是否相等，若内容相等，返回true。

==：是判断两个对象的地址是否相等，判断两个对象是不是同一个对象（基本数据类型==比较的是值、引用数据类型==比较是内存地址）

### 14.	为什么重写equals时必须重写hashCode？

> hashCode介绍：hashCode作用是获取哈希吗，也就是散列码。哈希吗的作用就是确定该对象在哈希表中的索引位置的。

为什么要写HashCode？以`HashSet`如何检查重复来说明。首先当你把对象加入到`HashSet`时候，`HashSet`会先计算对象的`hashCode`值来判断对象加入的位置，同时也会与该位置其他已经加入的对象的`hashCode`值比较。

比较如果不符合`hashCode、HashSet`会假设对象没有重复出现。如果发现有相同的`hashCode`值的对象，这时候就会调用`equals`方法来检查`hashCode`相等的对象是否真的相等还是假的相等。如果`hashCode、equals`都相等，那么`HashSet`就不会让其加入操作成功。如果不同就会重写散列到其他位置。

### 15.	什么是构造函数

构造器主要是用来完成对象的初始化工作的，它伴随着new操作一起调用的，不能直接调用，必须是系统自己调用的。值得注意的是，构造函数在对象实例化时会被自动调用，且只运行一次。

**衍生问题**：为什么要初始化？在类中定义的成员变量如果你没有初始化java会自动帮你初始化，如果是数字会自动初始化成0，对象引用会初始化成null。但是如果你在`局部变量`就必须初始化了，否则编译会报错。没有办法这就是Java的特点，这样也是为了提高代码安全性。

啰嗦两句：什么是局部变量？只在特定的过程或函数中可以访问的变量，被称为局部变量。定义在在方法、构造方法或者语句块中的。`局部变量是创建在栈内存中的`。

# 第二部分	Java集合

